/*
  This file is part of mjwm.
  Copyright (C) 2014  Chirantan Mitra <chirantan.mitra@gmail.com>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cstdlib>

#include "utils.h"
#include "messages.h"
#include "command_line_options.h"
#include "icon_service.h"
#include "desktop_file_names.h"
#include "representation.h"
#include "stats.h"
#include "menu.h"
#include "jwm/transformer.h"

namespace amm
{
  class main
  {
  private:
    amm::command_line_options command_line_options_;
    amm::menu menu_;
    std::vector<std::string> desktop_file_names_;

  public:
    void load_command_line_option(int argc, char **argv);
    void register_icon_service();
    void read_categories();
    void read_desktop_files();
    void populate();
    void write_output_file();
    void print_summary();
  };
}

void
amm::main::load_command_line_option(int argc, char **argv)
{
  command_line_options_ = amm::command_line_options();
  if (!command_line_options_.parse(argc, argv)) {
    std::cerr << amm::messages::option_error();
    exit(2);
  }
  std::vector<std::string> deprecations = command_line_options_.deprecations();
  if (deprecations.size() > 0) {
    std::cerr << amm::vectorx(deprecations).join("\n") << std::endl << "Proceeding..." << std::endl;
  }
  if (command_line_options_.is_help()) {
    std::cout << amm::messages::help() << std::endl;
    exit(0);
  }
  if (command_line_options_.is_version()) {
    std::cout << amm::messages::version() << std::endl;
    exit(0);
  }
}

void
amm::main::read_categories()
{
  std::string category_file_name = command_line_options_.category_file_name();
  std::vector<std::string> category_lines;

  if (category_file_name != "") {
    std::ifstream category_file(category_file_name.c_str());
    if (category_file.good()) {
      std::string line;
      while (std::getline(category_file, line)) {
        category_lines.push_back(line);
      }
      menu_.load_custom_categories(category_lines);
      category_file.close();
    } else {
      std::cerr << amm::messages::bad_category_file(category_file_name) << std::endl;
      exit(1);
    }
  }
}

void
amm::main::register_icon_service()
{
  amm::icon_service icon_service;
  icon_service.register_extension(command_line_options_.icon_extension());
  menu_.register_icon_service(icon_service);
}

void
amm::main::read_desktop_files()
{
  std::vector<std::string> input_directory_names = command_line_options_.input_directory_names();

  amm::desktop_file_names desktop_file_names;
  desktop_file_names.register_directories_with_default_fallback(input_directory_names);
  desktop_file_names.resolve();

  std::vector<std::string> bad_paths = desktop_file_names.bad_paths();
  if (bad_paths.size() > 0) {
    std::cerr << "These paths couldn't be opened: " << amm::vectorx(bad_paths).join(", ");
    std::cerr << std::endl << "Proceeding..." << std::endl;
  }
  desktop_file_names_ = desktop_file_names.all();
}

void
amm::main::populate()
{
  menu_.populate(desktop_file_names_);
  if (menu_.stats().total_parsed_files() == 0) {
    std::cerr << amm::messages::no_valid_desktop_files() << std::endl;
    exit(1);
  }
  menu_.sort();
}

void
amm::main::write_output_file()
{
  std::string output_file_name = command_line_options_.output_file_name();
  std::ofstream output_file(output_file_name.c_str());
  if (!output_file.good()) {
    std::cerr << amm::messages::bad_output_file(output_file_name) << std::endl;
    exit(1);
  }

  amm::transformer::jwm jwm_transformer;
  std::vector<amm::representation::base*> representations = menu_.representations();

  output_file << amm::messages::autogenerated_by_amm();

  for (std::vector<amm::representation::base*>::const_iterator representation = representations.begin(); representation != representations.end(); ++representation) {
    output_file << (*representation)->visit(jwm_transformer) << std::endl;
  }

  for (std::vector<amm::representation::base*>::iterator representation = representations.begin(); representation != representations.end(); ++representation) {
    delete *representation;
  }

  output_file.close();
}

void
amm::main::print_summary()
{
  std::cout << menu_.stats().summary();
}

int main(int argc, char *argv[])
{
  amm::main operation;
  operation.load_command_line_option(argc, argv);
  operation.register_icon_service();
  operation.read_categories();
  operation.read_desktop_files();
  operation.populate();
  operation.write_output_file();
  operation.print_summary();
}
