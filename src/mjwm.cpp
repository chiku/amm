/*
  This file is part of mjwm.
  Copyright (C) 2014  Chirantan Mitra <chirantan.mitra@gmail.com>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cstdlib>

#include "util.h"
#include "messages.h"
#include "command_line_options.h"
#include "icon_service.h"
#include "file_search_service.h"
#include "representation.h"
#include "stats.h"
#include "menu.h"
#include "jwm/transformer.h"

namespace amm
{
  class Main
  {
  private:
    amm::CommandLineOptions command_line_options_;
    amm::menu menu_;
    std::vector<std::string> desktop_file_names_;

  public:
    void LoadCommandLineOption(int argc, char **argv);
    void RegisterIconService();
    void ReadCategories();
    void ReadDesktopFiles();
    void Populate();
    void WriteOutputFile();
    void PrintSummary();
  };
}

void
amm::Main::LoadCommandLineOption(int argc, char **argv)
{
  command_line_options_ = amm::CommandLineOptions();
  if (!command_line_options_.Parse(argc, argv)) {
    std::cerr << amm::messages::option_error();
    exit(2);
  }
  std::vector<std::string> deprecations = command_line_options_.deprecations();
  if (deprecations.size() > 0) {
    std::cerr << amm::VectorX(deprecations).Join("\n") << std::endl << "Proceeding..." << std::endl;
  }
  if (command_line_options_.is_help()) {
    std::cout << amm::messages::help() << std::endl;
    exit(0);
  }
  if (command_line_options_.is_version()) {
    std::cout << amm::messages::version() << std::endl;
    exit(0);
  }
}

void
amm::Main::ReadCategories()
{
  std::string category_file_name = command_line_options_.category_file_name();
  std::vector<std::string> category_lines;

  if (category_file_name != "") {
    std::ifstream category_file(category_file_name.c_str());
    if (category_file.good()) {
      std::string line;
      while (std::getline(category_file, line)) {
        category_lines.push_back(line);
      }
      menu_.load_custom_categories(category_lines);
      category_file.close();
    } else {
      std::cerr << amm::messages::bad_category_file(category_file_name) << std::endl;
      exit(1);
    }
  }
}

void
amm::Main::RegisterIconService()
{
  amm::IconService icon_service;
  icon_service.set_extension(command_line_options_.icon_extension());
  menu_.register_icon_service(icon_service);
}

void
amm::Main::ReadDesktopFiles()
{
  std::vector<std::string> input_directory_names = command_line_options_.input_directory_names();

  amm::FileSearchService service;
  service.RegisterDirectoriesWithDefaultFallback(input_directory_names);
  service.Resolve();

  std::vector<std::string> bad_paths = service.bad_paths();
  if (bad_paths.size() > 0) {
    std::cerr << "These paths couldn't be opened: " << amm::VectorX(bad_paths).Join(", ");
    std::cerr << std::endl << "Proceeding..." << std::endl;
  }
  desktop_file_names_ = service.desktop_file_names();
}

void
amm::Main::Populate()
{
  menu_.populate(desktop_file_names_);
  if (menu_.stats().total_parsed_files() == 0) {
    std::cerr << amm::messages::no_valid_desktop_files() << std::endl;
    exit(1);
  }
  menu_.sort();
}

void
amm::Main::WriteOutputFile()
{
  std::string output_file_name = command_line_options_.output_file_name();
  std::ofstream output_file(output_file_name.c_str());
  if (!output_file.good()) {
    std::cerr << amm::messages::bad_output_file(output_file_name) << std::endl;
    exit(1);
  }

  amm::transformer::jwm jwm_transformer;
  std::vector<amm::representation::base*> representations = menu_.representations();

  output_file << amm::messages::autogenerated_by_amm();

  for (std::vector<amm::representation::base*>::const_iterator representation = representations.begin(); representation != representations.end(); ++representation) {
    output_file << (*representation)->visit(jwm_transformer) << std::endl;
  }

  for (std::vector<amm::representation::base*>::iterator representation = representations.begin(); representation != representations.end(); ++representation) {
    delete *representation;
  }

  output_file.close();
}

void
amm::Main::PrintSummary()
{
  std::cout << menu_.stats().summary();
}

int main(int argc, char *argv[])
{
  amm::Main operation;
  operation.LoadCommandLineOption(argc, argv);
  operation.RegisterIconService();
  operation.ReadCategories();
  operation.ReadDesktopFiles();
  operation.Populate();
  operation.WriteOutputFile();
  operation.PrintSummary();
}
