/*
  This file is part of mjwm.
  Copyright (C) 2014  Chirantan Mitra <chirantan.mitra@gmail.com>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cstdlib>

#include "util.h"
#include "messages.h"
#include "command_line_options.h"
#include "icon_service.h"
#include "file_search_service.h"
#include "representation.h"
#include "stats.h"
#include "menu.h"
#include "transformer/jwm.h"

namespace amm {

class Main {
 public:
  void LoadCommandLineOption(int argc, char **argv);
  void RegisterIconService();
  void ReadCategories();
  void ReadDesktopFiles();
  void Populate();
  void WriteOutputFile();
  void PrintSummary();

 private:
  CommandLineOptions command_line_options_;
  menu menu_;
  std::vector<std::string> desktop_file_names_;
};

void Main::LoadCommandLineOption(int argc, char **argv) {
  command_line_options_ = CommandLineOptions();
  if (!command_line_options_.Parse(argc, argv)) {
    std::cerr << messages::option_error();
    exit(2);
  }
  std::vector<std::string> deprecations = command_line_options_.deprecations();
  if (deprecations.size() > 0) {
    std::cerr << VectorX(deprecations).Join("\n") << std::endl << "Proceeding..." << std::endl;
  }
  if (command_line_options_.is_help()) {
    std::cout << messages::help() << std::endl;
    exit(0);
  }
  if (command_line_options_.is_version()) {
    std::cout << messages::version() << std::endl;
    exit(0);
  }
}

void Main::ReadCategories() {
  std::string category_file_name = command_line_options_.category_file_name();
  std::vector<std::string> category_lines;

  if (category_file_name != "") {
    std::ifstream category_file(category_file_name.c_str());
    if (category_file.good()) {
      std::string line;
      while (std::getline(category_file, line)) {
        category_lines.push_back(line);
      }
      menu_.load_custom_categories(category_lines);
      category_file.close();
    } else {
      std::cerr << messages::bad_category_file(category_file_name) << std::endl;
      exit(1);
    }
  }
}

void Main::RegisterIconService() {
  IconService icon_service;
  icon_service.set_extension(command_line_options_.icon_extension());
  menu_.register_icon_service(icon_service);
}

void Main::ReadDesktopFiles() {
  std::vector<std::string> input_directory_names = command_line_options_.input_directory_names();

  FileSearchService service;
  service.RegisterDirectoriesWithDefaultFallback(input_directory_names);
  service.Resolve();

  std::vector<std::string> bad_paths = service.bad_paths();
  if (bad_paths.size() > 0) {
    std::cerr << "These paths couldn't be opened: " << VectorX(bad_paths).Join(", ");
    std::cerr << std::endl << "Proceeding..." << std::endl;
  }
  desktop_file_names_ = service.desktop_file_names();
}

void Main::Populate() {
  menu_.populate(desktop_file_names_);
  if (menu_.stats().TotalParsedFiles() == 0) {
    std::cerr << messages::no_valid_desktop_files() << std::endl;
    exit(1);
  }
  menu_.sort();
}

void Main::WriteOutputFile() {
  std::string output_file_name = command_line_options_.output_file_name();
  std::ofstream output_file(output_file_name.c_str());
  if (!output_file.good()) {
    std::cerr << messages::bad_output_file(output_file_name) << std::endl;
    exit(1);
  }

  transformer::Jwm jwm_transformer;
  std::vector<representation::base*> representations = menu_.representations();

  output_file << messages::autogenerated_by_amm();

  for (std::vector<representation::base*>::const_iterator representation = representations.begin(); representation != representations.end(); ++representation) {
    output_file << (*representation)->visit(jwm_transformer) << std::endl;
  }

  for (std::vector<representation::base*>::iterator representation = representations.begin(); representation != representations.end(); ++representation) {
    delete *representation;
  }

  output_file.close();
}

void Main::PrintSummary() {
  std::cout << menu_.stats().Summary();
}

} // namespace amm


int main(int argc, char *argv[]) {
  amm::Main operation;
  operation.LoadCommandLineOption(argc, argv);
  operation.RegisterIconService();
  operation.ReadCategories();
  operation.ReadDesktopFiles();
  operation.Populate();
  operation.WriteOutputFile();
  operation.PrintSummary();
}
